# **_12.实践是检验真理的唯一标准：设计VSLAM系统**

人生是没有毕业的学校。——黎凯

---

> **本章主要内容** \
> 1.C++的工程结构 \
> 2.系统设计方法 \
> 3.设计一个VSLAM系统

教程选做环节，本节为教程结束实践环节，按照前面11节内容，设计一个VSLAM系统。<br />首先是开发语言，由于性能要求，一般SLAM工程需要C++来开发，因此我们的VSLAM系统会以一个C++工程的形式实现。而对于C++工程进行编译，一般使用CMAKE。

- 关于C++工程的目录结构，可以阅读下面这个链接了解：

[ 	cpp-project-structure Public](https://github.com/hattonl/cpp-project-structure)

- 关于CMAKE，可以通过这个了解：

[CMAKE手册](https://www.zybuluo.com/khan-lau/note/254724)<br />工欲善其事，必先利其器，一个趁手的开发工具可以加速开发进程。常见的写代码工具有vs code，QT，Clion等。<br />最后，需要了解运行平台，一般VSLAM算法都是跑在Linux系统上的，即ubuntu系统。在window上，可以通过VMware虚拟机来实现。<br />基本的准备工作做完了，现在来设计我们的VSLAM系统吧！
<a name="mdtXt"></a>
## 12.1 搭建厂房：工程框架确定
大多数Liux库都会按照模块对算法代码文件进行分类存放，譬如头文件会放在头文件目录中，源代码则放在源代码目录中。此外，可能还有配置文件、测试文件、三方库，等等。现在我们按照小型算法库的普遍做法分类，我们的文件：<br />1.在bin下存储编译好的二进制文件。<br />2.include/myslam存放SLAM模块的头文件，主要是.h文件。这种做法的目的是，当把包含目录设到include,引用自己的头文件时，需要写include"myslam/xxx.h",这样不容易和别的库混淆。<br />3.src存放源代码文件，主要是.cpp文件。<br />4.test存放测试用的文件，也是.cpp文件。<br />5.config存放配置文件。<br />6.cmake_modules存放第三方库的cmake文件，在使用g2o之类的库时会用到它。<br />这样就确定了代码文件的位置。接下来我们要讨论视觉里程计涉及的基础数据结构。

<a name="rBVSm"></a>
## 12.2 构建生产流水线：核心算法模块及流程的确定
确定工程框架，相当于把厂房搭建好。而系统的运行，则相当于厂房中的流水线，需要确定有哪些模块，各自负责哪道工序。<br />那么，我们需要确定这个加工的原材料是什么，有哪些工序，及加工的流程。<br />既然是VSLAM，那么我们加工的原材料就是图像。我们的上游厂家就是各类相机，比如单目相机，双目相机，RGBD相机等等。单目SLAM难度比较高，对于第一次开厂的我们不太友好，为了控制风险，这次选择加工难度较小的双目相机生产的双目图像。<br />确定了原材料，接下来就是技术选型了。我们知道一个SLAM系统大致分为

- 核心部分：前端，后端，回环检测，地图模块
- 周边模块：数据接入模块，相机模块，参数配置模块，可视化模块

首先是核心模块设计：<br />**前端：**<br />前端主要负责对图像数据提取特征并追踪特征，对当前帧的位姿进行估计，并判断当前帧是否为关键帧。将特征点追踪结果，关键帧的初始估计位姿送到后端进行优化，前端需要实时性较好。<br />以下是具体技术选型：

- 提取特征：为了平衡性能与精度，这里我们选择提取ORB特征。
- 特征追踪：考虑到追踪速度，这里使用光流追踪。
- 位姿估计：基于匀速相机模型，与上一帧建立追踪关系后，我们使用BA来获取当前帧相机的优化位姿。
- 特征点估计：在优化后，追踪结果为内点的特征点，追踪右目图像，并进行三角化获得3D空间坐标。

**后端：**<br />后端对前端估计的初始位姿及特征点进行局部和全局优化，并返回优化结果，对前端估计的位姿进行修正。后端的计算量很大，主要是修复前端的误差：即位姿估计的误差和错误的数据关联，这部分主流技术使用非线性优化。<br />以下是具体设计：

- 通过条件变量，当前端插入关键帧时，唤醒后端优化线程。
- 使用距离，来剔除最近与较远的关键帧，控制优化的关键帧为7帧。

**回环检测：**<br />完整的SLAM系统需要回环检测模块以修正长时间运行下的累计漂移，获得全局一致的地图。且回环检测模块可以在建好地图后进行重定位使用。

- 回环检测，使用DBoW3库作为回环检测库。

**地图模块：**<br />根据我们VSLAM应用的场景，需要确定最后生成何种类型的地图。如果只是定位，则使用路标点地图就可以了，但如果是进一步的导航等其他使用，则需要生成至少是半稠密的地图。<br />构建的地图主要用以定位，保存描述子信息就可以了。<br />以下是部分算法框架：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1782698/1685369544427-386444b2-fc5c-435b-bd05-372e09fc292d.png#averageHue=%23d2d2d2&clientId=ue894490e-9dfa-4&from=paste&height=332&id=u50b9e294&originHeight=415&originWidth=901&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=203744&status=done&style=none&taskId=u13d291b0-bad3-4db6-af1f-e334d5be6ec&title=&width=721)

<a name="YJ87b"></a>
## 12.3 基本数据结构设计
老的编程思想认为，程序就是算法加数据结构，在上面几节，我们自顶向下设计了工程框架，算法框架，完成了核心算法的设计，接下来最后一步，就是数据结构的设计了。数据结构就需要我们根据各模块的需求，抽象出需要使用的每个类，然后实现这些基本的数据结构。<br />安装需求，我们需要实现对应于每幅图像的帧这一类，即Frame类，然后是追踪的特征类，即Feature类，保存在地图中的用以定位的路标点，即MapPoint类。还有管理Frame和MapPoint的类，即Map类。

<a name="wc0DT"></a>
## 12.4 具体处理逻辑设计
在编码阶段，会涉及具体的处理逻辑。比如前端在根据双目图像确定该帧的位姿时，我们应该怎样使用右目的图像呢？是每一帧都和左右目各比较一遍，还是仅比较左右目之一呢？在三角化的时候，我们是考虑左右目图像的三角化，还是考虑时间上前后帧的三角化呢？实际中任意两张图像都可以做三角化（比如前一帧的左图对下一帧的右图），所以每个人实现起来也会不太一样。<br />为简单起见，我们先确定**前端的处理逻辑**：

- 1.前端本身有初始化、正常追踪、追踪丢失三种状态。
- 2.在初始化状态中，根据左右目之间的光流匹配，寻找可以三角化的地图点，成功时建立初始地图。
- 3.追踪阶段中，前端计算上一帧的特征点到当前帧的光流，根据光流结果计算图像位姿。该算只使用左目图像，不使用右目。
- 4.如果追踪到的点较少，就判定当前帧为关键帧。对于关键帧，做以下几件事：
   - 提取新的特征点：
   - 找到这些点在右图的对应点，用三角化建立新的路标点：
   - 将新的关键帧和路标点加入地图，并触发一次后端优化。
- 5.如果追踪丢失，就重置前端系统，重新初始化。

然后根据这个逻辑，我们就可以做实际的编码了。<br />**后端运行逻辑**为，在启动之后，将等待map_update的条件变量。当地图更新被触发时，从地图中拿取激活的关键帧和地图点，执行优化。

<a name="en9oJ"></a>
## 12.5 效果验证
在编码完成后，我们可以去下载一些公开的双目图像数据集，比如kitti数据集：http://www.cvlibs.net/datasets/.kitti/eval_odometry.php。读取该数据集，通过可视化界面查看系统运行效果。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1782698/1686926790766-c37b7eeb-0861-4679-a0a2-aef3cbe1570b.png#averageHue=%23dedddc&clientId=u4752411e-ae7c-4&from=paste&height=271&id=ucebeb0e8&originHeight=613&originWidth=1288&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=186963&status=done&style=none&taskId=u5727b4a4-ec92-4f5a-8358-c8a46702042&title=&width=570)<br />需要注意的是，练习代码中只包含前端和后端部分，回环检测及地图保存加载模块并未实现，有兴趣的同学可以尝试把这两个模块加到系统中。

<a name="Tg1lg"></a>
## 本章小结
本章主要介绍一个C++工程的基本结构，和如何自顶向下构建一个实际的VSLAM工程。
<a name="Qk86d"></a>
## 本章思考
1.如何把回环模块加入到系统中。<br />2.如何保存地图及加载地图。
<a name="zR4jk"></a>
## 本章练习
[设计VSLAM系统](https://github.com/https://github.com/datawhalechina/smoothly-vslam/tree/main/ch12hu-minghao/smoothly-vslam/tree/main/ch12)
<a name="P4ZBi"></a>
## 参考
0.视觉SLAM十四讲<br />[1.VS Code 基础教程（一）—— VS Code 的基本使用入门](https://blog.csdn.net/weixin_46215588/article/details/110160065)<br />[2.CMAKE手册](https://www.zybuluo.com/khan-lau/note/254724)




